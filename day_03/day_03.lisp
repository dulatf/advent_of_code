; (defun round-to-lowest-odd (n)
;   (let ((x (floor n)))
;     (if (= 0 (mod x 2)) (- x 1) x)))
; (defun ulam-spiral-position (mempos)
;  "Compute grid position of an elemnt of Ulam's spiral"
;   (let* ((root (+ 2 (round-to-lowest-odd (sqrt (- mempos (/ 1 2))))))
;          (cycle (/ (- root 1) 2))
;          (diff (- (expt root 2) mempos))
;          (side-len (+ (* cycle 2) 1)))
;   (format t "Mem pos: ~a~%" mempos)
;   (format t "Cycle: ~a~%" cycle)
;   (format t "Sqrt: ~a~%" root)
;   (format t "Diff: ~a~%" diff)
;   (format t "Side length: ~a~%" side-len)
;   (multiple-value-bind (div rem) (floor diff (- side-len 1))
;     (format t " / -> ~a~%" (vector div rem))
;     (let ((off (abs (- cycle rem))))
;     (format t " <-> ~a~%" off)
;       (values (+ off cycle))))))

; (defun make-spiral (gridsize)
;   "Fill a grid with Ulam's spiral"
;   (let ((n (+ (* 2 gridsize) 1)))
;     (format t "Creating a ~ax~a grid~%" n n)
;   (let ((grid (make-array (expt n 2) :adjustable nil :element-type 'integer :initial-element 0)))
;     (labels ((coord (x y) (+ x (* y n)))
;              (neighbors (x y)
;                (let ((out-coords (vector)))
;                  (cond ((and (< 0 x) (< 0 y)) (vector-push (coord (- x 1) (- y 1)) out-coords))
;                )))))
;     (setf (elt grid (coord gridsize gridsize)) 1)
;     (format t "~a~%" grid))))


(defclass spiral ()
  ((size :accessor size :initarg :size :initform 0)
   (grid :accessor grid)
   (state :accessor state :initform 'up)
   (cx :accessor cx :initform 0)
   (cy :accessor cy :initform 0)
   (counter :accessor counter :initform 1)))

(defmethod initialize-instance :after ((s spiral) &key)
   (format t "Making a spiral in a grid of size ~a.~%" (size s))
   (format t "Starting in state ~a.~%" (state s))
   (setf (grid s) (make-array (expt (size s) 2) :adjustable nil :element-type 'integer :initial-element 0))
   (let ((n (/ (- (size s) 1) 2)))
     (setf (elt (grid s) (grid-pos s n n)) 1)
     (setf (cx s) (+ n 1))
     (setf (cy s) n))
   (format t "The grid so far:~%")
   (print-grid s))
(defmethod grid-pos ((s spiral) x y)
  (+ x (* (size s) y)))
(defmethod valid-grid-pos ((s spiral) x y)
  (if (and (<= 0 x) (<= 0 y) (> (size s) x) (> (size s) y)) t nil))
(defmethod print-grid ((s spiral))
  (format t "Current state: ~a~%" (state s))
  (loop for i from 0 to (- (size s) 1) do
        (loop for j from 0 to (- (size s) 1) do
              (format t "~10d " (elt (grid s) (grid-pos s j i))))
        (format t "~%")))

(defmethod neighbors ((s spiral))
  (let ((out (make-array 8 :fill-pointer 0)))
    (flet ((pusher (x y)
             (when (valid-grid-pos s x y)
               (vector-push (grid-pos s x y) out))))
      (pusher (- (cx s) 1) (- (cy s) 1))
      (pusher    (cx s)    (- (cy s) 1))
      (pusher (+ (cx s) 1) (- (cy s) 1))

      (pusher (- (cx s) 1) (cy s))
      (pusher (+ (cx s) 1) (cy s))

      (pusher (- (cx s) 1) (+ (cy s) 1))
      (pusher    (cx s)    (+ (cy s) 1))
      (pusher (+ (cx s) 1) (+ (cy s) 1))
      out)))

(defmethod neighbor-sum ((s spiral))
  (let ((nbs (neighbors s)))
        (apply #'+ (map 'list (lambda (x) (elt (grid s) x)) nbs))))

(defmethod write-current-pos ((s spiral) &key (ulam t))
  (incf (counter s))
  (let ((val (if ulam (counter s) (neighbor-sum s))))
    (when (not ulam)
      (when (> val *input*)
        (format t "Value is bigger than the input: ~a~%" val)))
    (setf (elt (grid s) (grid-pos s (cx s) (cy s))) val)))

(defmethod right ((s spiral))
  (incf (cx s))
  (when (and (valid-grid-pos s (cx s) (- (cy s) 1))
             (= 0 (elt (grid s) (grid-pos s (cx s) (- (cy s) 1)))))
    (setf (state s) 'up)))
(defmethod up ((s spiral))
  (decf (cy s))
  (when (and (valid-grid-pos s (- (cx s) 1) (cy s))
             (= 0 (elt (grid s) (grid-pos s (- (cx s) 1) (cy s)))))
    (setf (state s) 'left)))
(defmethod left ((s spiral))
  (decf (cx s))
  (when (and (valid-grid-pos s (cx s) (+ (cy s) 1))
             (= 0 (elt (grid s) (grid-pos s (cx s) (+ (cy s) 1)))))
    (setf (state s) 'down)))
(defmethod down ((s spiral))
  (incf (cy s))
  (when (and (valid-grid-pos s (+ (cx s) 1) (cy s))
             (= 0 (elt (grid s) (grid-pos s (+ (cx s) 1) (cy s)))))
    (setf (state s) 'right)))

(defmethod generate ((s spiral))
  (dotimes (i (- (expt (size s) 2) 1))
    (write-current-pos s :ulam nil)
    (funcall (state s) s)))
(defvar *input* 277678)
(let ((sp (make-instance 'spiral :size 9)))
  (generate sp)
  (print-grid sp))
